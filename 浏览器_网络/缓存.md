### 为什么要使用web缓存？

- 冗余的数据传输：防止服务器传输同一份文档，消耗网络宽带，降低传输速度，加重服务器负载
- 宽带瓶颈：网络为本地网络客户端提供的带宽 大于 为远程服务器提供的带宽，获取副本的速度可能更快
- 瞬间拥塞：处理多个人同时访问一个web文档，导致瞬间拥塞和网络崩溃的紧急情况
- 距离时延：降低文件传输距离造成的时延



### 如何进行缓存再验证？Re-Validation

在不从服务器上获取整个对象的情况下，快速检测出内容是否是**最新的**，以判断缓存是否命中。HTTP使用If-Modified-Since首部进行验证。

- **再验证命中：**如果文本未被修改，服务器向客户端发送 HTTP 304 Not Modified响应
- **再验证未命中：**服务器内容与缓存副本不同，服务器发送完整的 HTTP 200 OK 响应
- **对象被删除：**服务器返回 HTTP 404 Not Found响应，同时缓存删除副本



### 命中率 Hit Rate

- 缓存命中率：缓存提供服务的请求所占比利
- 字节命中率：缓存的字节所占比例
- 缺陷：用户不能判断资源是否来源于缓存，客户端可以使用Date首部进行日期比较，或Age首部检测缓存响应的使用期。



### 缓存的拓扑结构 

缓存分为公有的和私有的。

- 私有缓存：不需要很大的空间，web浏览器中有内建的私有缓存
- 公有代理缓存：接受来自多个用户的访问，减少冗余流量

#### 1. 多级缓存 Cache Hierarchy

靠近客户端的地方使用小型廉价缓存，高层中逐步采用更大更强的缓存，以装载多用户共享的文档。

- 子缓存：兴趣点分散，性能要求高，小型廉价
- 父缓存：装载多用户之间流行的文档，接受子缓存的聚合流量，容量更大

#### 2. 网状缓存 Cache Mesh

在父级缓存和服务器之间进行动态选择。

- 兄弟缓存：对等的实体，HTTP协议并不支持，使用ICP/HTCP进行扩展



### 如何保证缓存副本的新鲜度？

#### 1. 文档过期 Document Expiration

服务器设定**Cache-Control: Max-Age**和**Expires**首部为每个文档添加过期日期：客户端判断是否过期，如果不过期直接获取，如果过期则请求服务器再验证。

- Cache-Control：Max-Age相比Expires使用的是相对时间，设置最大的合法生存时间
- Expires：使用绝对时间，依赖计算机时间的设置

#### 2. 服务器再验证 Server Revalidation

**验证内容变化：**缓存获取新的文档副本，储存在旧文档的位置上

**验证内容没有变化：**缓存获取新的首部和新的过期日期，更新缓存中的文档

- 文档过期后，让原始服务器验证，文档是否真的发生了变化。
- If-Modified-Since / Last-Modified: **根据修改时间验证**
  1. 原始服务器添加最后修改日期
  2. 缓存在进行再验证时，添加If-Modifed-Since首部，携带最后修改的日期
  3. 服务器判断文档的最后修改时间是否不同，相同则返回304
  4. 缺点：文档周期性重写但内容无变化；文档被修改但不重要；服务器无法判断准确修改时间等
- If-None-Match: **根据实体标签Etag验证**
  1. 发布者修改文档时，可以选择修改文档的实体标签来声明这个新的版本，修改Etag
  2. 服务器判断Etag是否匹配



### 如何控制缓存？

- no-store：禁止缓存对响应进行复制
- no-cache：进行服务器再验证之前缓存不能提供给客户端使用
- max-age：文档处于新鲜状态的时长，设置为0则不进行文档缓存
- Expires：指定实际过期日期
- must-revalidate：必须进行服务器再验证
- 试探性过期：在没有设定过期时间时，缓存计算出试探性最大使用期



### 缓存带来的问题？

向原始服务器隐藏实际的访问次数，如果实际收益和访问次数相关，将会产生问题。















