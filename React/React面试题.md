### 1. Props vs State

- - Props 是组件的属性 对外的接口：

- - - **只读**
    - 总是从父组件传递到子组件
    - 传递大量数据
    - 只能通过父组件修改（单向流动数据流）

- - State 是组件的状态 对内的接口：

- - - 通过 this.state( )访问

    - 通过 this.setState( ) 异步更新 （React 优化执行时机, 合并多次修改）

    - **每个组件有自己的\*\***state,\*\* **只存在于组件内部\*\***,\*\* **反应组件内部的变化**，私有的

    - **可变**

    - 存放少量的定义数据

### 2. Props vs State

- - 挂载阶段

- - - Constructor 构造函数
    - Render 返回需要渲染的内容 纯函数
    - ComponentDidMount 组件装载之后调用 可获取 DOM 节点并操作

- - 更新阶段

- - - ComponentDidUpdate 用于状态更新

- - 卸载阶段

- - - ComponentWillMount 组件销毁前被调用 用于垃圾清理

### 3. **React Redux**

- - **状态容器，用于整个应用的状态管理**

  - **\*\*状态管理\*\***

    状态管理库，无论是 Redux，还是 Mobx 这些，其本质都是为了解决状态管理混乱，无法有效同步的问题，它们都支持：

    1. 统一维护管理应用状态；

    2. 某一状态只有一个可信数据来源（通常命名为 store，指状态容器）；

    3. 操作更新状态方式统一，并且可控（通常以 action 方式提供更新状态的途径）；

    4. 支持将 store 与 React 组件连接，如 react-redux，mobx-react；通常使用状态管理库后，我们将 React 组件从业务上划分为两类：

    5. 1. 容器组件（Container Components）：负责处理具体业务和状态数据，将业务或状态处理函数传入展示型组件；

       2. 展示型组件（Presentation Components）：负责展示视图，视图交互回调内调用传入的处理函数；

  - **三个原则：**

- - - 单一来源：整个应用的状态储存在 store 中的对象里
    - 状态只读：改变状态的唯一方法是触发一个 action
    - 使用纯函数进行更改（纯函数：返回值仅取决于参数）
    - 纯函数的优点：cachable，easy-testable

- - **Redux vs Mobx**

- - - Redux 只有一个 store，mobx 多个分散的 store, 平级且互不影响

    - Redux 使用不可变状态，状态是只读的，只能通过纯函数返回新的状态；Mobx 状态可变，能直接修改

    - Redux 状态可以回溯，方便调试；Mobx 有更多的封装，调试困难

    - Mobx 是组件订阅 Store

    - Redux 提倡编写函数式代码，如 reducer 就是一个纯函数（pure function）纯函数，接受输入，然后输出结果，除此之外不会有任何影响，也包括不会影响接收的参数；对于相同的输入总是输出相同的结果。

    - Mobx 设计更多偏向于面向对象编程（OOP）和响应式编程（Reactive Programming），通常将状态包装成可观察对象，于是我们就可以使用可观察对象的所有能力，一旦状态对象变更，就能自动获得更新。

    - Store 是应用管理数据的地方，在 Redux 应用中，我们总是将所有共享的应用数据集中在一个大的 store 中，而 Mbox 则通常按模块将应用状态划分，在多个独立的 store 中管理

    - > Redux 默认以 JavaScript 原生对象形式存储数据，而 Mbox 使用可观察对象

      > Redux 需要手动追踪所有状态对象的变更 Mobx 中可以监听可观察对象，当其变更时将自动触发监听

    - Redux 状态对象通常是不可变的（Immutable）：我们不能直接操作状态对象，而总是在原来状态对象基础上返回一个新的状态对象，这样就能很方便的返回应用上一状态；而 Mobx 中可以直接使用新值更新状态对象。

- - Redux 优点

    - 结果的可预测性，不存在同步问题

    - 可维护性

    - 可回溯, 方便调试

    - 架构层面上讲，我们希望 UI 跟数据和逻辑分离，UI 只负责渲染，业务和逻辑交由其它部分处理，从数据流向方面来说, 单向数据流确保了整个流程清晰。

      我们之前的操作可以复制、追踪出来，这也是 Redux 的主要设计思想。

      综上，Redux 可以做到：

      - 每个 State 变化可预测。

      - 动作与状态统一管理。

  - Redux 缺点

    - 组件所需要的数据必须从父组件传过来，不能直接从 store 获取
    - 组件更新时，父组件必须更新，即使不需要用到

### **4. React 特点**

- - 使用虚拟 DOM：

- - - 虚拟 DOM 是 JS object, 对真实 DOM 的抽象
    - 虚拟 DOM 通过 diff 找到差异, 无需手动操作 DOM, 提高开发效率, 内存消耗少
    - 将差异更新到真实 DOM 中

- - 单向数据绑定：

- - - 数据 props 从父组件->子组件
    - 父组件传递回调函数, 子组件调用回调函数, 此函数用于更新父组件
    - 父级改变, React 重新渲染子节点

​

### **5. key 的作用**

Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。

在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。

在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。

### **6. 在哪个周期发送 AJAX 请求**

我们应当将 AJAX 请求放到 componentDidMount 函数中执行，主要原因有下：
React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。
如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了 setState 函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题。
