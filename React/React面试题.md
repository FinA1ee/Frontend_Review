

### 1. Props vs State

- - Props是组件的属性 对外的接口：

- - - **只读**
    - 总是从父组件传递到子组件
    - 传递大量数据
    - 只能通过父组件修改（单向流动数据流）

- - State是组件的状态 对内的接口：

- - - 通过this.state( )访问

    - 通过this.setState( ) 异步更新 （React优化执行时机, 合并多次修改）

    - **每个组件有自己的****state,** **只存在于组件内部****,** **反应组件内部的变化**，私有的

    - **可变**

    - 存放少量的定义数据

      

### 2. Props vs State

- - 挂载阶段

- - - Constructor构造函数
    - Render返回需要渲染的内容 纯函数
    - ComponentDidMount组件装载之后调用 可获取DOM节点并操作

- - 更新阶段

- - - ComponentDidUpdate用于状态更新

- - 卸载阶段

- - - ComponentWillMount组件销毁前被调用 用于垃圾清理

      

### 3. **React Redux**

- - **状态容器，用于整个应用的状态管理**

  - ***\*状态管理\****

    

    状态管理库，无论是Redux，还是Mobx这些，其本质都是为了解决状态管理混乱，无法有效同步的问题，它们都支持：

    

    1. 统一维护管理应用状态；

    2. 某一状态只有一个可信数据来源（通常命名为store，指状态容器）；

    3. 操作更新状态方式统一，并且可控（通常以action方式提供更新状态的途径）；

    4. 支持将store与React组件连接，如react-redux，mobx-react；通常使用状态管理库后，我们将React组件从业务上划分为两类：

    5. 1. 容器组件（Container Components）：负责处理具体业务和状态数据，将业务或状态处理函数传入展示型组件；

       2. 展示型组件（Presentation Components）：负责展示视图，视图交互回调内调用传入的处理函数；

          

  - **三个原则：**

- - - 单一来源：整个应用的状态储存在store中的对象里
    - 状态只读：改变状态的唯一方法是触发一个action
    - 使用纯函数进行更改（纯函数：返回值仅取决于参数）
    - 纯函数的优点：cachable，easy-testable

- - **Redux vs Mobx**

- - - Redux只有一个store，mobx多个分散的store, 平级且互不影响

    - Redux使用不可变状态，状态是只读的，只能通过纯函数返回新的状态；Mobx状态可变，能直接修改

    - Redux状态可以回溯，方便调试；Mobx有更多的封装，调试困难

    - Mobx是组件订阅Store

    - Redux提倡编写函数式代码，如reducer就是一个纯函数（pure function）纯函数，接受输入，然后输出结果，除此之外不会有任何影响，也包括不会影响接收的参数；对于相同的输入总是输出相同的结果。 

    - Mobx设计更多偏向于面向对象编程（OOP）和响应式编程（Reactive Programming），通常将状态包装成可观察对象，于是我们就可以使用可观察对象的所有能力，一旦状态对象变更，就能自动获得更新。

    - Store是应用管理数据的地方，在Redux应用中，我们总是将所有共享的应用数据集中在一个大的store中，而Mbox则通常按模块将应用状态划分，在多个独立的store中管理

    - > Redux默认以JavaScript原生对象形式存储数据，而Mbox使用可观察对象

      > Redux需要手动追踪所有状态对象的变更 Mobx中可以监听可观察对象，当其变更时将自动触发监听

    - Redux状态对象通常是不可变的（Immutable）：我们不能直接操作状态对象，而总是在原来状态对象基础上返回一个新的状态对象，这样就能很方便的返回应用上一状态；而Mobx中可以直接使用新值更新状态对象。

- - Redux优点

    - 结果的可预测性，不存在同步问题

    - 可维护性

    - 可回溯, 方便调试

    - 架构层面上讲，我们希望UI跟数据和逻辑分离，UI只负责渲染，业务和逻辑交由其它部分处理，从数据流向方面来说, 单向数据流确保了整个流程清晰。

      我们之前的操作可以复制、追踪出来，这也是Redux的主要设计思想。

      综上，Redux可以做到：

      - 每个State变化可预测。

      - 动作与状态统一管理。

        

  - Redux缺点

    - 组件所需要的数据必须从父组件传过来，不能直接从store获取
    - 组件更新时，父组件必须更新，即使不需要用到



### **4. React特点**

- - 使用虚拟DOM：

- - - 虚拟DOM是JS object, 对真实DOM的抽象
    - 虚拟DOM通过diff找到差异, 无需手动操作DOM, 提高开发效率, 内存消耗少
    - 将差异更新到真实DOM中

- - 单向数据绑定：

- - - 数据props从父组件->子组件
    - 父组件传递回调函数, 子组件调用回调函数, 此函数用于更新父组件
    - 父级改变, React重新渲染子节点

​		

### **5. key的作用**

Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。

在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。

在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。



### **6. 在哪个周期发送AJAX请求**

我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下：
React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。
如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题。





