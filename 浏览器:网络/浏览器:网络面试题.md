### Topic 1 浏览器相关

1. http1.0 vs http1.1 vs http 2.0 （提高页面响应速度，减少延迟时间）

   - HTTP/2新添加的内容

     a. 一个TCP连接下的多路复用

     b. 压缩头部，减少头部体积，对头部进行编码

     c. 添加请求优先级

     d. 添加服务器推送，单个请求多次响应，不需明确请求额外推送资源

     e. 二进制格式取代文本格式

   - 多路复用的原理？

     a. 在http1.x中实现请求并行必须开启多个TCP连接，一个请求后才能执行下一个，线头阻塞。

     b. 多路复用让客户端和服务器把消息分解成独立的帧，交错传输，在另一端组装。使得一个TCP连接上可以有多个请求，根据id分配给不同的服务器。某个耗时的请求不会影响后面。

     

2. 浏览器加载网页经过

   - 浏览器根据url通过DNS数据库找到服务器的ip地址

   - 向服务器80端口发送请求，和服务器建立TCP连接

   - 发送HTTP报文

   - 收到HTTP回复报文

   - 解析HTTP报文，分别并行生成DOM树和CSS树，合并形成渲染树

   - 比较渲染树，进行回流和重绘操作

   - 像素信息发送给GPU渲染在网页上

     

3. 回流 vs 重绘

   - 回流：因为元素的规模尺寸，几何位置发生改变，需要重新构建部分渲染树的过程

   - 重绘：渲染树构造完成后，修改字体颜色等，不改变渲染树的重新布局

   - 哪些情况会产生回流？

     a. 改变DOM树的构造，文本内容/位置改变，可见元素的删减/添加

     b. display: hidden

     c. 改变浏览器窗口尺寸，准确计算offset

   - 如何减少回流重绘？

     a. 减少对DOM和渲染树的操作

     b. 减少每次操作所对应的节点

     c. 将css属性一次性写入

     

4. 浏览器缓存

   - 目的：减少网络请求资源的距离，减少延迟，重复利用，减少网络符合

   - 强缓存：

     ​	a. 不会向服务器发送请求，直接从缓存读取资源

     ​	b. Expires：指定资源到期时间，服务器告诉客户端在指定的时间之间再次请求可以直接读取数据

     ​	c. Cache-Control：通过设置Max-age等参数设置缓存

   - 协商缓存：

     ​	a. 强缓存失效后，向服务器发送请求，服务器决定是否使用缓存

     ​	b. 缓存命中，返回304，资源没有更新；缓存失效，返回200，服务器返回新的请求结果

     ​	c. Last-Modified: 浏览器再次请求时添加If-Modified-Since，和其作对比。

     ​		弊端：最小单位是秒，无法感知更小时间单位的修改。

     ​	d. Etag: 服务器给每个资源生成的唯一标识，资源被修改后，etag重新生成。浏览器请求时，服务器比较etag判断资源是否被		修改。

     ​	e. 比较：Etag更精确，耗时更长

     

5. 会话跟踪

   - 什么是会话跟踪技术？

     来自于一个用户的所有请求都应该属于一个会话。由于HTTP连接的无状态性，数据交换完成连接关闭后，服务器端无法进行会话跟踪，无法记录用户状态。

     

   - Cookie：浏览器端记录用户信息

     ​	a. 一段小的文本信息。如果服务器需要记录用户状态，在第一次请求后，服务器会向浏览器发送一段Cookie保存用户信息。再		次请求登录时，浏览器将这个Cookie一并发送，由客户端验证或修改。

     ​	b. Cookie操作：Java中有Cookie类，服务器操作Cookie类来修改客户端的Cookie。例如设定失效时间。

     ​	c. Cookie特点：

     ​		不可跨域名：相同的域名操作相同的Cookie，保护用户隐私安全。

     ​		HttpOnly：不能通过脚本获得Cookie值，防止XSS攻击

     ​		修改Cookie：Cookie不提供删改操作。新建同名Cookie覆盖旧Cookie，设置maxAge=0删除Cookie。

     ​		安全属性：设置Secure，Cookie只会在安全的HTTPS和SSL协议下传输。

     

   - Session：服务器端记录用户信息

     ​	a. Session存放在内存中，每个用户有独立的Session

     ​	b. 每次用户访问，服务器记录并维护Session

     ​	c. 长期不活跃的用户的Session会被服务器删除

     

6. 事件冒泡和捕获

   - 冒泡：事件从最深的节点开始，逐步向上传播

   - 捕获：事件从window开始，逐步向下传播

   - 事件委托：将子元素的响应事件委托给父级，让父元素进行监听

     ```javascript
     // 节省内存占用，减少事件注册，在ul上代理所有li的onclick事件
     
     <ul id="myLinks">
       <li id="goSomewhere">Go somewhere</li>
       <li id="doSomething">Do something</li>
       <li id="sayHi">Say hi</li>
     </ul>
     
     var item1 = document.getElementById("goSomewhere");
     var item2 = document.getElementById("doSomething");
     var item3 = document.getElementById("sayHi");
     
     // js原生实现委托
     document.addEventListener("click", function (event) {
       var target = event.target;
       switch (target.id) {
         case "doSomething":
           document.title = "事件委托";
           break;
         case "goSomewhere":
           location.href = "http://www.baidu.com";
           break;
         case "sayHi": alert("hi");
           break;
       }
     })
     ```

     

   - 阻止冒泡：e.stopPropagation( )

   - 阻止默认事件：e.preventDefault( )

     

7. 跨域

   - 什么是跨域？

     跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是***\*浏览器施加的\****安全限制。

     同源：域名，协议，端口均相同。

   - 跨域的解决方法？

     ​	a. JSONP：只对GET请求有效

     ​	b. 代理模式，编写接口绕过浏览器解决跨域问题

     ​	c. CORS：跨域资源共享，使用额外的HTTP请求头允许浏览器访问跨域资源

     ​		浏览器：在header中加入请求头字段origin

     ​		服务器：在header中加入Access-Control-Allow-Origin字段

     ​		再次请求时服务器进行检查

     ​		非简单请求时，浏览器发送options请求预检，如果服务器支持，再发送真正的请求到后端。

     

8. 节流防抖

   - 为什么使用节流防抖

     JS中的鼠标，输入等事件会不断调用绑定在事件上的回调函数，极大浪费资源，降低前端性能。为了优化体验，要对此类事件进行调用的限制。

   - 防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

     ```javascript
     let timer; // 维护同一个timer
     function debounce(fn, delay){
       clearTimeout(timer);
       timer = setTimeout(function(){
         fn();
       }, delay)
     }
     
     function testDebounce() {
         console.log('test');
     }
     document.onmousemove = () => {
         debounce(testDebounce, 1000);
     }
     ```

   - 节流：每隔一段时间，只执行一次回调

     ```javascript
      function throttle(fn,delay){
          // 记录上一次触发的时间
          var lasttime = 0 ;
          // 通过闭包的方式使用lasttime变量，每次都是上次的时间
          return function(){
              // 
              var nowtime = Date.now();
              if(nowtime-lasttime>delay){
                  // 修正this函数问题
                  fn.call(this);
                  // 同步时间
                  lasttime = nowtime;
              }
          }
          
      }
     
     // test
     function testThrottle(e, content) {
         console.log(e, content);
     }
     let testThrottleFn = throttle(testThrottle, 1000); // 节流函数
     document.onmousemove = function (e) {
         testThrottleFn(e, 'throttle'); // 给节流函数传参
     }
     ```

   - 防抖实际运用

     ​	a. 手机号/邮箱验证

     ​	b. 窗口大小resize

   - 节流实际运用

     ​	a. 表单的重复提交

   

   

   ### Topic 2 网络相关

   1. TCP

      - 三次握手

      - 四次挥手

      - 拥塞控制

      - 流量控制

        

   2. 什么是HTTP？

      - 超文本传输协议，在web上传输文本文档（html）的一种方法

      

   3. HTTP vs HTTPs

      - 在HTTP基础上计入了SSL协议，依靠证书验证服务器身份，在传输层进行通信加密。

      - HTTP为明文传输，不受保护，直接与TCP连接。

      - HTTPS运行在SSL行，SSL运行在TCP上，可以进行身份认证，更加安全。

        

   4. 长连接 vs 短连接

      - 短连接：每进行一次HTTP操作，就建立一个连接

      - 长连接：Connection = Keep-Alive

        ​	a. HTTP1.1默认保持长连接，减少HTTP重新连接的消耗的时间

        ​	b. 服务器可以通过长连接主动推送资源到客户端 

        

   5. web安全防护

      - XSS 跨站脚本攻击

        ​	a. 注入非法脚本或HTML代码控制用户浏览器

        ​	b. 窃取用户Cookie和个人信息等

        ​	c. 防御：HttpOnly属性设置

      - CSRF 跨站请求伪造

        ​	a. 冒充用户发起请求

        ​	b. 验证码，限制请求来源等

        

   6. FTP文件传输协议

      

   7. HTTP方法

      - GET：服务器向客户端发送资源

      - PUT：客户端数据存入服务器资源

      - DELETE：从服务器删除资源

      - POST：将客户端数据发送到服务器应用程序

      - HEAD：响应资源的HTTP头部

        

   8. HTTP报文

      - 纯文本格式，非二进制

      - 报文构成：

        ​	a. 起始行：请求报文中说明请求，响应报文中说明响应情况

        ​	b. 首部字段：content-type等

        ​	c. 主体：主要包含数据

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

   

   

   

   

   

   

   

   

   

   

   

   ​	 

   

   

   

   

