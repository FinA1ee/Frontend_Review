### Let/Const的特性，与Var的区别？

* 两者均是新增声明命令, let 用于变量, const 用于常量
* 都只能在所在的代码块中使用
* 都不存在变量提升
* 都有暂时性死区
* 都不能再同一个作用域反复声明

```javascript
// 变量提升
console.log(v1); // undefined
var v1 = 100;
function foo() {
    console.log(v1); // undefined
    var v1 = 200;
    console.log(v1); // 200
}
foo();
console.log(v1); // 100

// 暂时性死区
var tmp = 123;
if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
```

### 强类型和弱类型有什么区别？

### 严格模式与非严格模式有什么区别？

### 什么是变量提升？ 会带来什么问题？

用 var 定义变量可以在被声明前使用/调取, 值为 undefined

### 什么是暂时性死区？

变量在声明前不可被使用, 直到声明才能被使用

### 什么是块级作用域？

* ES5只有全局作用域和函数作用域
* 代码块外部的作用域无法读取内部作用域的变量
* 防止同名内层变量覆盖外层变量

### 什么是闭包？

- 声明在另一个函数内部的函数

- 内部函数对外部函数的变量进行引用, 行程闭包

- 优点：避免了使用全局变量, 避免了全局变量被污染的可能, 函数内部变量被保护

- 缺点：由于垃圾回收机制, 变量不会被垃圾回收, 造成内存泄漏


### 什么是执行上下文

- JS代码执行时生成的环境, 包含所有变量和对象

- 执行函数或块级代码时, 在当前上下文上层, 建立一个新的上下文环境, 形成一个stack

- 直到所有代码执行完成, 清空堆栈


### JS中的事件循环是怎么样的？

- 目的：为了处理Ajax网络请求, setTimeout等异步任务,  避免cpu资源浪费

- 任务队列：主线程执行时, 遇到异步ajax, setTimeout任务, 将任务暂时放入任务队列中。当主线程完全处于空闲状态时, 在从任务队列中调取下一个task执行。

- 微任务 / 宏任务：Promise产生的任务队列为微任务。宏任务队列有多个, 微任务队列有一个。

- 主线程优先查找微任务队列。


### JS中的垃圾回收是怎样的？

- 标记清除：

  ​	a. 进入环境的所有变量进行标记，离开环境时再次被标记，并准备删除

  ​	b. 判断一个对象是否可以获得 （有零个引用的对象总是不可获得的）

  ​	c. 从root对象开始查询, 没有循环引用的问题

- 引用计数：一个对象有访问另一个对象的权限

  ​	a. 当对象不再被引用, 则被垃圾回收

  ​	b. 当两个对象相互引用而都不被第三方引用, 则被垃圾回收


### JS中如何判断对象为空？

- 将JSON对象转换为字符串，判断是否为空

- for in循环

- ES6中的Object.keys获取属性名的数组，判断长度


### JS中的数据额类型分为哪几类？

- 基本类型: 数字、字符串、布尔值、null、undefined
- 引用类型: 对象、Array类型、Function类型

### 引用类型 vs 基本类型？

|      |                       基本类型                       |                          引用类型                           |
| ---- | :--------------------------------------------------: | :---------------------------------------------------------: |
| 变量 |                  简单值, 储存值本身                  |               储存的是对象在Heap内存中的地址                |
| 存储 |                 变量存在Stack内存中                  |   变量(地址) 储存在Stack内存中, 对象本身储存在Heap内存中    |
| 大小 |                   根据类型确定大小                   |                    指针(地址) 固定4字节                     |
| 比较 |       同类直接比较值, 不同类进行隐式转换后比较       |                      比较的是内存地址                       |
| 例子 | var a = 1; var b = a; 复制的只是值本身, 改变b不改变a | var a = {}; var b = a; a和b指向同一个内存地址, a加属性b也加 |

### Null vs undefined ？

```javascript
null == undefined; // true
null === undefined; // false
var a = null; // typeof(a) 是对象, 值为null
var a = undefined; // typeof(a) 是undefined, 值为undefined
```

### JS如何进行数据类型转化

- 转成数字类型：Number( ), parseInt( ), parseFloat( )
- 转成字符串：toString( ), String( )

### JS如何判断数据类型

- typeof i.e null -> object
- instanceof 通过原型链判断继承
- Object.prototype.toString









