## 脚本的执行

1. 当 HTML 解析器遇到<script/>tag 时, 必须默认执行先脚本, 在执行前后面的文档都不会渲染 (可能需要等待脚本下载)
2. 脚本的执行默认为同步/阻塞的, <script/>标签可以有 async/defer 属性 (boolean)
   - defer 属性: 浏览器延迟脚本的运行, 直到文档的载入和解析完成 (window.onload())
   - async 属性: 浏览器会尽快执行脚本, 而不在下载脚本时阻塞 (同时使用会忽略 defer 属性)

## 客户端 JS 的线程模型

1. JS/客户端 JS 语言核心本身没有定义任何线程机制
2. HTML5 定义了 WebWorker 后台线程
3. 单线程的问题:
   - 在执行脚本/事件处理程序时, 必须停止响应用户输入
   - 脚本执行计算密集型的任务, 会给文档的载入带来延迟, 用户在脚本运行结束前无法看到文档内容 (某些浏览器会给用户终止脚本运行的机会)

## 客户端 JS 执行时间线

1. 浏览器创建 Document 对象, 解析 Web 页面, 将相应的 Element 对象添加到文档中
2. 执行脚本(根据是否含有 async 属性来同步/异步执行)
3. 进入异步事件驱动阶段
4. 文档解析完成, 等待异步脚本等所有内容完成载入后, 触发 window.onload 事件
5. 调用异步事件来响应用户交互

## 标准模型 / 怪异模型

1. 两种渲染模式
2. 选择依赖于 HTML 文件的顶部 DOCTYPE 声明
3. 检查 document.compatMode 属性
   - CSS1Compat: 标准模式
   - BackCompat: 怪异模式

## 检测浏览器的类型 / 版本

1. Navigator 对象

## 安全性

1. JS 的局限

   - 没有权限写入/删除客户计算机上的文件或目录
   - 不能删改数据/植入病毒
   - 不能基于浏览器用 JS 和别的浏览器通信, 没有通用的网络能力
   - 同源策略 (防止脚本窃取其他页面的用户输入)

2. 同源策略

   - 一种安全限制: 限制 JS 代码能操作哪些 Web 内容
   - 同源的定义: 协议/主机/URL 端口相同
   - 防止脚本窃取信息

3. 跨域资源共享

   - 使用新的 Origin 请求头 / Access-Control-Allow-Origin 响应头
   - 扩展 HTTP: 服务器用 Header 信息列出 Origin

4. 跨站脚本 XSS
   - 攻击者向目标站点注入 HTML/脚本
   - 恶意脚本可能读取站点储存的 Cookie
   - 防御: 移出 HTML 标签, 对 HTML 标签进行转义和过滤删除
   - HTML5 的 sandbox 属性
