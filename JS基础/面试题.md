### **Topic 1: Let / Const及相关问题**

1. ES6 新增的 Let 和 Const
   * 两者均是新增声明命令, let 用于变量, const 用于常量
   * 都只能在所在的代码块中使用
   * 都不存在变量提升
   * 都有暂时性死区
   * 都不能再同一个作用域反复声明

2. 什么是变量提升？ 会带来什么问题？

   * 用 var 定义变量可以在被声明前使用/调取, 值为 undefined

     ```javascript
     console.log(v1); // undefined
     var v1 = 100;
     function foo() {
         console.log(v1); // undefined
         var v1 = 200;
         console.log(v1); // 200
     }
     foo();
     console.log(v1); // 100
     ```

   

3. 什么是暂时性死区？

   * 变量在声明前不可被使用, 直到声明才能被使用

     ```javascript
     var tmp = 123;
     if (true) {
       tmp = 'abc'; // ReferenceError
       let tmp;
     }
     ```

     

4. 什么是块级作用域？

   * ES5只有全局作用域和函数作用域
   * 代码块外部的作用域无法读取内部作用域的变量
   * 防止同名内层变量覆盖外层变量

5. 什么是闭包？

   

### **Topic 2: JS中的数据类型**

1. JS中的数据额类型分为哪几类？
   - 基本类型: 数字、字符串、布尔值、null、undefined
   - 引用类型: 对象、Array类型、Function类型

2. 引用类型 vs 基本类型

   |      |                       基本类型                       |                          引用类型                           |
   | ---- | :--------------------------------------------------: | :---------------------------------------------------------: |
   | 变量 |                  简单值, 储存值本身                  |               储存的是对象在Heap内存中的地址                |
   | 存储 |                 变量存在Stack内存中                  |   变量(地址) 储存在Stack内存中, 对象本身储存在Heap内存中    |
   | 大小 |                   根据类型确定大小                   |                    指针(地址) 固定4字节                     |
   | 比较 |       同类直接比较值, 不同类进行隐式转换后比较       |                      比较的是内存地址                       |
   | 例子 | var a = 1; var b = a; 复制的只是值本身, 改变b不改变a | var a = {}; var b = a; a和b指向同一个内存地址, a加属性b也加 |

   

3. Null vs undefined

   ```javascript
   null == undefined; // true
   null === undefined; // false
   var a = null; // typeof(a) 是对象, 值为null
   var a = undefined; // typeof(a) 是undefined, 值为undefined
   ```

4. JS数据类型转化

   - 转成数字类型：Number( ), parseInt( ), parseFloat( )

   - 转成字符串：toString( ), String( )

     

### **Topic 3: 箭头函数**

1. 箭头函数和普通函数有什么区别？

   - **箭头函数this的指向是固定的**，没有自己的this

     ```javascript
     function foo() {
       setTimeout(() => {
         console.log('id:', this.id);
       }, 100);
     }
     
     var id = 21;
     
     foo.call({ id: 42 }); // 42 this指向定义生效时的对象 {id: 42}
     ```

   - 函数体内的this, 指向定义时的对象, 非使用时的对象

   - 不可用作构造函数, 不能使用new命令

   - 不可以使用argument对象, 可以用rest参数替代

   - 不可以使用yield命令, 不能用作generator函数

     

2. 箭头函数的使用场合和不适用场合

   - 适用于封装回调函数, 得益于静态的this, DOM事件的回调函数封装在对象内

     ```javascript
     var handler = {
       id: '123456',
     
       init: function() {
         document.addEventListener('click',
           event => this.doSomething(event.type), false); // 调用对象内的doSomething
       },
     
       doSomething: function(type) {
         console.log('Handling ' + type  + ' for ' + this.id);
       }
     };
     ```

   - 不适用于定义对象的方法

   - 不适用于需要动态this的时候



### **Topic 4: Promise对象**

1. 什么是Promise对象？引入Promise的目的是什么？

   - 是ES6中异步编程的一种解决方案

   - 将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数

   - 三种状态：resolved / rejected / pending

   - Promise实例

     ```javascript
     // Promise实例
     function timeout(ms){
       return new Promise(function(resolve, reject)){
      		setTimeout(resolve, ms, "done");                    
       });
     }
      
     timeout(100).then((value) => { // then接受了一个回调函数作为参数
       console.log(value); // done
     })
     
     // 图片加载模板
     function loadImageAsync(url) {
       return new Promise(function(resolve, reject) {
         const image = new Image();
     
         image.onload = function() {
           resolve(image);
         };
     
         image.onerror = function() {
           reject(new Error('Could not load image at ' + url));
         };
     
         image.src = url;
       });
     }
     
     // 链式调用
     getJSON("/post/1.json").then(function(post) {
       return getJSON(post.commentURL); // 返回一个新的Promise实例, 等待这个实例状态变化
     }).then(function (comments) {
       console.log("resolved: ", comments);
     }, function (err){
       console.log("rejected: ", err);
     });
     
     // Promise错误的冒泡性质
     getJSON('/post/1.json').then(function(post) {
       return getJSON(post.commentURL);
     }).then(function(comments) { // some code
     }).catch(function(error) { // 处理前面三个Promise产生的错误
     });
     
     // 使用finally在最后关闭服务器
     server.listen(port)
       .then(function () { // ...
       })
       .finally(server.stop);
     ```

     

2. Promise API中的方法

   - then( ): Promise实例状态改变时的回调函数

   - catch( ): Promise实例异步操作中抛出的错误, 或then中抛出的错误, 用catch处理, Promise中的错误具有冒泡性质

   - finally( ): 不管Promise的状态如何都会执行的回调函数

   - all( ): 将多个Promise实例, 包装成一个Promise实例, 参数为一个数组。

     ​	a. 数组中所有实例状态变为resolved, 则为resolved。返回值组成数组传给回调函数。

     ​	b. 数组中一个实例状态变为rejected, 则为rejected。第一个rejected的返回值传给回调函数。

   - race( ): 将多个Promise实例, 包装成一个Promise实例

     ​	a. 任一个实例状态改变, 则新实例的状态就跟着改变。率先改变的返回值传给回调函数。

   - any( ): 将多个Promise实例, 包装成一个Promise实例

     ​	a. 数组中一个实例状态变为resolved, 则为resolved。

     ​	b. 数组中所有实例状态变为rejected, 则为rejected。

   - resolve( ) / reject( ): 将一个对象转变为Promise实例

     ​	a. 对象为Promise对象: 不改变, 直接返回

     ​	b. 对象为thenable对象: 转为Promise对象, 执行then方法

     ​	c. 对象不是thenable对象: 转为Promise对象, 状态为resolved, 回调函数立即执行

     

3. Promise的缺点

   - 无法取消Promise, 新建后就会执行
   - 如果没有回调函数, Promise内部的错误无法反应到外部
   - Pending状态时无从得知异步操作进行到了哪一阶段

### **Topic 5: Async函数**



