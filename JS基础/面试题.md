### **Topic 1: Let / Const及相关问题**

1. ES6 新增的 Let 和 Const
   * 两者均是新增声明命令, let 用于变量, const 用于常量
   * 都只能在所在的代码块中使用
   * 都不存在变量提升
   * 都有暂时性死区
   * 都不能再同一个作用域反复声明

2. 什么是变量提升？ 会带来什么问题？

   * 用 var 定义变量可以在被声明前使用/调取, 值为 undefined

   ```javascript
   console.log(v1); // undefined
   var v1 = 100;
   function foo() {
       console.log(v1); // undefined
       var v1 = 200;
       console.log(v1); // 200
   }
   foo();
   console.log(v1); // 100
   ```

   

3. 什么是暂时性死区？

   * 变量在声明前不可被使用, 直到声明才能被使用

     ```javascript
     var tmp = 123;
     if (true) {
       tmp = 'abc'; // ReferenceError
       let tmp;
     }
     ```

     

4. 什么是块级作用域？

   * ES5只有全局作用域和函数作用域
   * 代码块外部的作用域无法读取内部作用域的变量
   * 防止同名内层变量覆盖外层变量



5. 什么是闭包？

   

### **Topic 2: JS中的数据类型**

1. JS中的数据额类型分为哪几类？
   - 基本类型: 数字、字符串、布尔值、null、undefined
   - 引用类型: 对象、Array类型、Function类型

2. 引用类型 vs 基本类型

   |      |                       基本类型                       |                          引用类型                           |
   | ---- | :--------------------------------------------------: | :---------------------------------------------------------: |
   | 变量 |                  简单值, 储存值本身                  |               储存的是对象在Heap内存中的地址                |
   | 存储 |                 变量存在Stack内存中                  |   变量(地址) 储存在Stack内存中, 对象本身储存在Heap内存中    |
   | 大小 |                   根据类型确定大小                   |                    指针(地址) 固定4字节                     |
   | 比较 |       同类直接比较值, 不同类进行隐式转换后比较       |                      比较的是内存地址                       |
   | 例子 | var a = 1; var b = a; 复制的只是值本身, 改变b不改变a | var a = {}; var b = a; a和b指向同一个内存地址, a加属性b也加 |

   

3. Null vs undefined

   ```javascript
   null == undefined; // true
   null === undefined; // false
   var a = null; // typeof(a) 是对象, 值为null
   var a = undefined; // typeof(a) 是undefined, 值为undefined
   ```

4. JS数据类型转化

   - 转成数字类型：Number( ), parseInt( ), parseFloat( )
   - 转成字符串：toString( ), String( )



### **Topic 3: 箭头函数**

1. 