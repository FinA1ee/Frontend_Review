### **Topic 1: JS基本概念

1. ES6 新增的 Let 和 Const
   * 两者均是新增声明命令, let 用于变量, const 用于常量
   * 都只能在所在的代码块中使用
   * 都不存在变量提升
   * 都有暂时性死区
   * 都不能再同一个作用域反复声明

2. 什么是变量提升？ 会带来什么问题？

   * 用 var 定义变量可以在被声明前使用/调取, 值为 undefined

     ```javascript
     console.log(v1); // undefined
     var v1 = 100;
     function foo() {
         console.log(v1); // undefined
         var v1 = 200;
         console.log(v1); // 200
     }
     foo();
     console.log(v1); // 100
     ```

   

3. 什么是暂时性死区？

   * 变量在声明前不可被使用, 直到声明才能被使用

     ```javascript
     var tmp = 123;
     if (true) {
       tmp = 'abc'; // ReferenceError
       let tmp;
     }
     ```

     

4. 什么是块级作用域？

   * ES5只有全局作用域和函数作用域
   * 代码块外部的作用域无法读取内部作用域的变量
   * 防止同名内层变量覆盖外层变量

5. 什么是闭包？

   

6. 执行上下文

   - JS代码执行时生成的环境, 包含所有变量和对象

   - 执行函数或块级代码时, 在当前上下文上层, 建立一个新的上下文环境, 形成一个stack

   - 直到所有代码执行完成, 清空堆栈

     

7. 事件循环

8. 垃圾回收

### **Topic 2: JS中的数据类型**

1. JS中的数据额类型分为哪几类？
   - 基本类型: 数字、字符串、布尔值、null、undefined
   - 引用类型: 对象、Array类型、Function类型

2. 引用类型 vs 基本类型

   |      |                       基本类型                       |                          引用类型                           |
   | ---- | :--------------------------------------------------: | :---------------------------------------------------------: |
   | 变量 |                  简单值, 储存值本身                  |               储存的是对象在Heap内存中的地址                |
   | 存储 |                 变量存在Stack内存中                  |   变量(地址) 储存在Stack内存中, 对象本身储存在Heap内存中    |
   | 大小 |                   根据类型确定大小                   |                    指针(地址) 固定4字节                     |
   | 比较 |       同类直接比较值, 不同类进行隐式转换后比较       |                      比较的是内存地址                       |
   | 例子 | var a = 1; var b = a; 复制的只是值本身, 改变b不改变a | var a = {}; var b = a; a和b指向同一个内存地址, a加属性b也加 |

   

3. Null vs undefined

   ```javascript
   null == undefined; // true
   null === undefined; // false
   var a = null; // typeof(a) 是对象, 值为null
   var a = undefined; // typeof(a) 是undefined, 值为undefined
   ```

4. JS数据类型转化

   - 转成数字类型：Number( ), parseInt( ), parseFloat( )

   - 转成字符串：toString( ), String( )

     

### **Topic 3: 箭头函数**

1. 箭头函数和普通函数有什么区别？

   - **箭头函数this的指向是固定的**，没有自己的this

     ```javascript
     function foo() {
       setTimeout(() => {
         console.log('id:', this.id);
       }, 100);
     }
     
     var id = 21;
     
     foo.call({ id: 42 }); // 42 this指向定义生效时的对象 {id: 42}
     ```

   - 函数体内的this, 指向定义时的对象, 非使用时的对象

   - 不可用作构造函数, 不能使用new命令

   - 不可以使用argument对象, 可以用rest参数替代

   - 不可以使用yield命令, 不能用作generator函数

     

2. 箭头函数的使用场合和不适用场合

   - 适用于封装回调函数, 得益于静态的this, DOM事件的回调函数封装在对象内

     ```javascript
     var handler = {
       id: '123456',
     
       init: function() {
         document.addEventListener('click',
           event => this.doSomething(event.type), false); // 调用对象内的doSomething
       },
     
       doSomething: function(type) {
         console.log('Handling ' + type  + ' for ' + this.id);
       }
     };
     ```

   - 不适用于定义对象的方法

   - 不适用于需要动态this的时候



### **Topic 4: Promise对象**

1. 什么是Promise对象？引入Promise的目的是什么？

   - 是ES6中异步编程的一种解决方案

   - 将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数

   - 三种状态：resolved / rejected / pending

   - Promise实例

     ```javascript
     // Promise实例
     function timeout(ms){
       return new Promise(function(resolve, reject)){
      		setTimeout(resolve, ms, "done");                    
       });
     }
      
     timeout(100).then((value) => { // then接受了一个回调函数作为参数
       console.log(value); // done
     })
     
     // 图片加载模板
     function loadImageAsync(url) {
       return new Promise(function(resolve, reject) {
         const image = new Image();
     
         image.onload = function() {
           resolve(image);
         };
     
         image.onerror = function() {
           reject(new Error('Could not load image at ' + url));
         };
     
         image.src = url;
       });
     }
     
     // 链式调用
     getJSON("/post/1.json").then(function(post) {
       return getJSON(post.commentURL); // 返回一个新的Promise实例, 等待这个实例状态变化
     }).then(function (comments) {
       console.log("resolved: ", comments);
     }, function (err){
       console.log("rejected: ", err);
     });
     
     // Promise错误的冒泡性质
     getJSON('/post/1.json').then(function(post) {
       return getJSON(post.commentURL);
     }).then(function(comments) { // some code
     }).catch(function(error) { // 处理前面三个Promise产生的错误
     });
     
     // 使用finally在最后关闭服务器
     server.listen(port)
       .then(function () { // ...
       })
       .finally(server.stop);
     ```

     

2. Promise API中的方法

   - then( ): Promise实例状态改变时的回调函数

   - catch( ): Promise实例异步操作中抛出的错误, 或then中抛出的错误, 用catch处理, Promise中的错误具有冒泡性质

   - finally( ): 不管Promise的状态如何都会执行的回调函数

   - all( ): 将多个Promise实例, 包装成一个Promise实例, 参数为一个数组。

     ​	a. 数组中所有实例状态变为resolved, 则为resolved。返回值组成数组传给回调函数。

     ​	b. 数组中一个实例状态变为rejected, 则为rejected。第一个rejected的返回值传给回调函数。

   - race( ): 将多个Promise实例, 包装成一个Promise实例

     ​	a. 任一个实例状态改变, 则新实例的状态就跟着改变。率先改变的返回值传给回调函数。

   - any( ): 将多个Promise实例, 包装成一个Promise实例

     ​	a. 数组中一个实例状态变为resolved, 则为resolved。

     ​	b. 数组中所有实例状态变为rejected, 则为rejected。

   - resolve( ) / reject( ): 将一个对象转变为Promise实例

     ​	a. 对象为Promise对象: 不改变, 直接返回

     ​	b. 对象为thenable对象: 转为Promise对象, 执行then方法

     ​	c. 对象不是thenable对象: 转为Promise对象, 状态为resolved, 回调函数立即执行

     

3. Promise的缺点

   - 无法取消Promise, 新建后就会执行
   - 如果没有回调函数, Promise内部的错误无法反应到外部
   - Pending状态时无从得知异步操作进行到了哪一阶段

### **Topic 5: Generator函数**

1. 什么是Generator函数？有哪些特点

   - 异步编程的一种解决方法

   - 状态机, 封装多个内部状态

   - 返回遍历器, 可以遍历Generator中的内部状态

   - for...of循环可以直接遍历Generator函数, 不需要next方法

     ```javascript
     // Generator写法
     function* helloWorldGenerator() {
       yield 'hello';
       yield 'world';
       return 'ending';
     }
     
     var hw = helloWorldGenerator();
     hw.next() // { value: 'hello', done: false }
     hw.next() // { value: 'world', done: false }
     hw.next() // { value: 'ending', done: true } done表示遍历是否结束
     hw.next() // { value: undefined, done: true }
     
     // 将Generator赋值给对象的Iterator接口
     var myIterable = {};
     myIterable[Symbol.iterator] = function* () {
       yield 1;
       yield 2;
       yield 3;
     };
     
     [...myIterable] // [1, 2, 3]
     
     // 给next带参数 例子1
     function* f() {
       for(var i = 0; true; i++) {
         var reset = yield i;
         if(reset) { i = -1; }
       }
     }
     
     var g = f();
     
     g.next() // { value: 0, done: false }
     g.next() // { value: 1, done: false }
     g.next(true) // { value: 0, done: false }
     
     // 给next带参数 例子2
     function* foo(x) {
       var y = 2 * (yield (x + 1));
       var z = yield (y / 3);
       return (x + y + z);
     }
     
     var a = foo(5);
     a.next() // Object{value:6, done:false}
     a.next() // Object{value:NaN, done:false}
     a.next() // Object{value:NaN, done:true}
     
     var b = foo(5);
     b.next() // { value:6, done:false }
     b.next(12) // { value:8, done:false }
     b.next(13) // { value:42, done:true }
     
     // Generator实现Tick/Tock状态机
     var clock = function* () {
       while (true) {
         console.log('Tick!');
         yield;
         console.log('Tock!');
         yield;
       }
     };
     ```

     

2. yield表达式的作用是什么？
   - 暂停标志
   - 遇到yield, 暂停执行
   - 下一次调用next时, 再继续执行

3. next参数的作用是什么？

   - yield返回undefined

   - next的参数给上一个yield设置返回值

     

4. 遍历器中有哪些方法？

   - throw: 返回的遍历器对象, 可以跑出错误, 在函数体内捕获, 内部捕获前必须执行一次next

     ```javascript
     // 抛出错误
     var g = function* () {
       try {
         yield;
       } catch (e) {
         console.log('内部捕获', e);
       }
     };
     
     var i = g();
     i.next();
     
     try {
       i.throw('a'); // 内部捕获 a new Error("...")
       i.throw('b'); // 外部捕获 b
     } catch (e) {
       console.log('外部捕获', e);
     }
     
     // 例子2
     var gen = function* gen(){
       try {
         yield console.log('a');
       } catch (e) {
         // ...
       }
       yield console.log('b');
       yield console.log('c');
     }
     
     var g = gen();
     g.next() // a
     g.throw() // b
     g.next() // c
     ```

   - return: 终结遍历Generator函数

     ```javascript
     function* numbers () {
       yield 1;
       try {
         yield 2;
         yield 3;
       } finally {
         yield 4;
         yield 5;
       }
       yield 6;
     }
     var g = numbers();
     g.next() // 1
     g.next() // 2
     g.return(7) // 4 return直接进入finally
     g.next() // 5
     g.next() // 7 执行完finally后结束
     
     ```

   - yield* 表达式: 在一个Generator中调用另外一个, 解决手动遍历的问题

     ```javascript
     // 不用yield*手动遍历
     function* foo() {
       yield 'a';
       yield 'b';
     }
     
     function* bar() {
       yield 'x';
       for (let i of foo()) {
         console.log(i); // 手动遍历 foo()
       }
       yield 'y';
     }
     
     for (let v of bar()){
       console.log(v); // x a b y
     }
     
     // 使用yield*
     function* foo() {
       yield 'a';
       yield 'b';
     }
     
     function* bar() {
       yield 'x';
       yield* foo();
       yield 'y';
     }
     ```

     

5. Generator的应用场景

   ​	a. 异步操作的同步化表达

   ​	b. 控制流管理

   ​	c. 在对象上部署Iterator接口, 作为一个类似数组的数据结构

   

6. Generator函数的异步运用

   - 如何实现: 通过yield交出协程的执行权, 等待执行权返回

   - Thunk函数: 传名调用的一种实现方案

     ```javascript
     // 包装一个异步任务
     var fetch = require('node-fetch');
     
     function* gen(){
       var url = 'https://api.github.com/users/github';
       var result = yield fetch(url); // 返回Promise对象
       console.log(result.bio);
     }
     
     // 执行
     var g = gen();
     var result = gen.next();
     
     result.value.then(function(data){
       return data.json();
     }).then(function(data){
       g.next(data);
     });如何实现: 通过yield交出协程的执行权, 等待执行权返回
     ```





















